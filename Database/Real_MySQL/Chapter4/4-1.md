## 4-1 <mysql 엔진 아키텍처>

<img width="1037" height="515" alt="img" src="https://github.com/user-attachments/assets/6d0aec1e-027c-46d1-bfc9-83a39ab7a434" />

위 사진과 같이 크게는
Connection Handler
MySqlEngine
StorageEngine
HW 으로 구성되어 있다. 

* **흐름:** 클라이언트가 요청을 보내면, 커넥션 핸들러가 받아 스레드를 할당하고, 엔진이 쿼리를 분석한 뒤, 스토리지 엔진에게 데이터를 가져오라고 명령합니다.
### 2. 스레딩 구조 (Threading)

MySQL은 **Process**가 아닌 **Thread** 기반으로 작동합니다.

#### ① Foreground Thread (전면 데스크)
* 역할: 클라이언트(사용자)와 1:1로 연결되어 실제 요청을 처리.
* 작업: `SELECT`(읽기) 뿐만 아니라 `INSERT`, `UPDATE`(쓰기) 요청도 받습니다.
* 특징: 쓰기 작업 시, 데이터 버퍼(메모리)에만 빠르게 기록하고 실제 디스크 기록은 뒤로 미룹니다.

#### ② Background Thread (물류 창고)
* 역할: 사용자와 직접 대화하지 않고 뒤에서 묵묵히 일 처리.
* 작업:
    * Log Thread: 로그를 디스크에 기록.
    * Write Thread: 버퍼(메모리)에 있던 데이터를 실제 디스크(데이터 파일)로 옮김 (Flushing).
    * 기타: **데드락 감시** 등.
* **중요:** InnoDB의 핵심은 이 백그라운드 스레드가 얼마나 효율적으로 디스크에 데이터를 내려쓰느냐에 달려 있습니다.
- 
### memory

#### ① Global Memory (공유 영역)
* 특징: MySQL 서버가 시작될 때 OS로부터 할당받음. 모든 스레드가 공유.
* 포함: `InnoDB Buffer Pool` (가장 중요), `Table Cache` 등.

#### ② Local / Session Memory (전용 영역)
* 특징: 클라이언트 스레드별로 독립적으로 할당됨. 절대 공유되지 않음.
* 포함: `Join Buffer`, `Sort Buffer`, `Network Buffer`.
* **⚠️ 주의 (OOM 위험):** 커넥션이 많을 때 `Sort Buffer`나 `Join Buffer` 사이즈를 너무 크게 설정하면, 메모리 부족(OOM)으로 서버가 죽을 수 있음.
* 
### plug in and component

#### ① 플러그인 (Plugin) - 구식
* 스토리지 엔진, 인증 모듈, 검색어 파 등을 플러그인 형태로 끼워 쓸 수 있음.
* **단점:** * 플러그인끼리 통신 불가능.
    * 캡슐화 안 됨 (전역 변수 오염 가능성).
    * 초기화 순서 제어 어려움.

#### ② 컴포넌트 (Component) - 신식 (MySQL 8.0+)
* 플러그인의 단점을 해결하기 위해 등장.
* **개선점:**
    * **Service Registry:** 컴포넌트끼리 통신할 수 있는 중개소 존재.
    * **인터페이스 기반:** 내부 로직을 숨기고(캡슐화), 정해진 인터페이스로만 소통.

## 좀 중요한 정보들

### 쿼리 실행

`Parser -> Preprocessor -> Optimizer`
- parser : 문법 확인, 괄호 닫혔는지
- Preprocessor : 실존 여부 체크, 권한 체크
- **Optimizer** : 실제 과거 데이터 조회 방법이나 테이블 구조를 바탕으로 **실행 계획**을 짬. (인덱스 사용 여부 등)



### ① Thread Pool vs Thread Cache
* **Thread Cache (Community Edition 기본):**
    * 스레드를 미리 만들어두진 않음.
    * 하지만 사용이 끝난 스레드를 바로 버리지 않고 **캐시(대기실)**에 보관했다가 재사용.
    * OS의 스레드 생성/소멸 비용(Context Switching)을 줄임.
* **Thread Pool (Enterprise Edition 기능):**
    * 스레드 개수를 엄격하게 제한(Limit)하고, 넘치는 요청은 큐(Queue)에 대기시킴.
    * CPU 폭주를 막아 트래픽이 몰려도 처리 속도를 일정하게 유지.

### ② HikariCP(Client)와 MySQL(Server)의 관계
> **"HikariCP는 전화기를 들고 있는 것, Thread Cache는 상담원을 대기시키는 것"**

1.  **HikariCP:** `minimumIdle` 설정만큼 커넥션을 미리 맺어둠 (TCP 연결 비용 절약).
2.  **평상시:** 커넥션이 유지되므로 MySQL 스레드도 죽지 않고 살아있음 (1:1 매핑).
3.  **트래픽 감소 시:** * HikariCP가 불필요한 커넥션을 끊음 (`close`).
    * MySQL은 해당 스레드를 삭제하지 않고 **Thread Cache**로 보냄.
4.  **트래픽 급증 시:**
    * HikariCP가 다시 연결 요청 (`connect`).
    * MySQL은 `new Thread`를 하지 않고, **Thread Cache**에서 자고 있던 스레드를 꺼내서 즉시 할당.

> **결론:** HikariCP(네트워크 비용 절감)와 Thread Cache(CPU 비용 절감)는 서로 보완적인 관계다.




---

## 백엔드 개발자 필수 지식 (실무 & 면접용)

이론을 넘어, 실제 Spring Boot 개발자가 이 아키텍처를 알아야 하는 이유입니다.

### ① 커넥션 풀(HikariCP)을 무조건 크게 잡으면 안 되는 이유
* **상황:** "동시 접속자가 많으니 `maximumPoolSize`를 1000개로 늘리자!"
* **아키텍처 관점의 반박:**
    * MySQL은 기본적으로 **1 Connection = 1 Thread** 구조입니다.
    * 커넥션이 1000개면 스레드도 1000개가 생성됩니다.
    * CPU 코어는 한정적인데 스레드가 너무 많으면, 실제 일하는 시간보다 스레드를 교체하는 **컨텍스트 스위칭(Context Switching)** 비용이 더 커져서 성능이 급격히 떨어집니다.
* **결론:** DB 서버의 CPU 코어 수에 맞춰 적절한 값을 찾아야 합니다. (공식: `Core * 2 + effective_spindle_count`)

### ② OOM(Out Of Memory) 발생 원인과 해결
* **상황:** "DB 서버 메모리가 충분한데 자꾸 뻗어요."
* **아키텍처 관점의 분석:**
    * **Global Memory(InnoDB Buffer Pool)**는 고정되어 있어 안전하지만,
    * **Local Memory(Sort Buffer, Join Buffer)**는 **커넥션(스레드) 개수만큼** 할당됩니다.
    * 예: `Sort Buffer`를 10MB로 설정하고 커넥션이 500개 열리면, 정렬 작업 시 순식간에 5GB(10MB * 500)가 추가로 필요해집니다.
* **결론:** `Sort_buffer_size`, `Join_buffer_size` 같은 로컬 메모리 설정은 너무 크게 잡으면 위험합니다.

### ③ "쿼리가 느려요"의 원인 파악 (Layer 구분)
쿼리 튜닝 시 문제가 어디인지 파악하는 기준이 됩니다.
* **MySQL 엔진 문제:**
    * `Parser/Optimizer` 단계에서 비효율적인 실행 계획을 짬 (인덱스를 안 탐).
    * 해결: 쿼리 재작성, 힌트 사용, 인덱스 추가.
* **스토리지 엔진(InnoDB) 문제:**
    * 실행 계획은 좋은데, 디스크 I/O가 너무 많거나 락(Lock)이 걸림.
    * 해결: 버퍼 풀 크기 조정, 트랜잭션 격리 수준 조정, 스키마 변경.

### ④ Transaction 지원 여부 (MyISAM vs InnoDB)
* **상황:** 아주 옛날 레거시 DB를 만났는데 트랜잭션(`@Transactional`)이 안 먹힘.
* **이유:** 스토리지 엔진이 **MyISAM**인 경우 트랜잭션을 지원하지 않습니다.
* **필수:** 백엔드 개발자는 무조건 **InnoDB**를 사용해야 ACID(원자성, 일관성, 고립성, 지속성)가 보장됩니다.
